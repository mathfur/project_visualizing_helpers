#!/usr/bin/env python

import lldb
import os
import pprint
from optparse import OptionParser, OptionValueError

import lib.python.lldb_helper as helper

usage = "usage: %prog debug_built_ruby_bin_file target_ruby_file"
parser = OptionParser(usage)

(options, args) = parser.parse_args()

if not args or len(args) < 2:
    parser.error("require ruby_bin and target_ruby_file")
    parser.print_help()
    exit()

ruby_bin = args[0]
ruby_target_file = args[1]

if not os.path.exists(ruby_bin):
    parser.error("ruby_bin file `%s` is not exist" % ruby_bin)
    parser.print_help()
    exit()

if not os.path.exists(ruby_target_file):
    parser.error("ruby targate file `%s` is not exist" % ruby_target_file)
    parser.print_help()
    exit()

debugger = lldb.SBDebugger.Create()
debugger.SetAsync (False)

target = debugger.CreateTargetWithFileAndArch(ruby_bin, lldb.LLDB_ARCH_DEFAULT)
res = lldb.SBCommandReturnObject()

if target:
    h = helper.LLDBFrame(target, None, None)
    bp = target.BreakpointCreateByName("rb_call", target.GetExecutable().GetFilename());
    
    bp.SetCondition("argc > 1")

    process = target.LaunchSimple([ruby_target_file], None, os.getcwd())
    if process:
        while True:
            state = process.GetState()
            if state == lldb.eStateStopped:
                thread = process.GetThreadAtIndex(0)
                if thread:
                    frame = thread.GetFrameAtIndex(0)
                    h = helper.LLDBFrame(target, process, frame)
                    print "current_fname = %s;" % h.current_fname()
                    process.Continue()
            else:
                break
